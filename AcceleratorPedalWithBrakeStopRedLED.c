#pragma config(Sensor, in1,    lineTracker,    sensorLineFollower)
#pragma config(Sensor, dgtl1,  bumpSwitch,     sensorTouch)
#pragma config(Sensor, dgtl2,  limitSwitch,    sensorTouch)
#pragma config(Sensor, dgtl11, red,            sensorLEDtoVCC)
#pragma config(Sensor, dgtl12, green,          sensorLEDtoVCC)
#pragma config(Motor,  port1,           firstMotor,    tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           rightMotor,    tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
	Project Title: accelerator with limit switch and LED's.
	Author: Adrian Wisla
*/


task main()
{

SensorValue(dgtl12) = true;								// this turns on the led in digital port 11; you can also give it the variable name (red) instead of the port.
SensorValue(dgtl11) = false;


	while(1) {															// a condition that will always be true to run the program forever. (1) is a shortcut. What other ways of infinite loops can you think of?


		if(SensorValue(bumpSwitch) == 1 && SensorValue(limitSwitch) != 1) //  two conditions using &&, which means that both have to be true.
		{
			SensorValue(green) = true;					// what is the difference between using true and 1 in this case?
			SensorValue(red) = false;
			setMotor(port1, 60);								// this starts the motor when the bump switch and the limitSwitch is off.

		} else { stopAllMotors(); }						// this stops the motor in any other case (the limit switch not being pressed in)

		if(SensorValue(limitSwitch) == 1){		// this takes action when the limit switch is pressed in
			stopAllMotors();										// stops any mnotor
			SensorValue(red) = 1;								// here using the variable-looks cleaner.
			SensorValue(green) = 0;							// also pay attention to using digits 1 and 0 instead of true and false.
		}

}

}
